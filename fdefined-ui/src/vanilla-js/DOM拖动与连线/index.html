<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Drag and Connect DOM Elements</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      position: relative;
    }

    #box1,
    #box2 {
      display: flex;
      align-items: center;
      width: 300px;
      height: 100px;
      background: skyblue;
      position: absolute;
      cursor: pointer;
      z-index: 1;
      box-sizing: border-box;
      padding: 10px;
      border-radius: 8px;
    }

    #line {
      stroke: black;
      stroke-width: 2;
    }

    .icon {
      height: 100%;
      background-color: cadetblue;
      flex: 0 1 30%;
    }

    .desc {
      flex: 1;
      height: 100%;
      background-color: azure;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .wrp {
      position: fixed;
      background-color: #666;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>

  <div class="wrp">
    <div class="draggable" id="box1" style="top: 100px; left: 100px;">
      <div class="icon"></div>
      <div class="desc"></div>
    </div>
    <div class="draggable" id="box2" style="top: 100px; left: 300px;">
      <div class="icon"></div>
      <div class="desc"></div>
    </div>
    <svg>
      <line id="line" x1="0" y1="0" x2="0" y2="0" />
    </svg>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', (event) => {

      let selectedElement = null;
      const line = document.getElementById('line');
      const connectors = [];

      function makeDraggable(el) {
        const element = el;
        element.addEventListener('mousedown', startDrag);
        element.addEventListener('mousemove', drag);
        element.addEventListener('mouseup', endDrag);
        element.addEventListener('mouseleave', endDrag);

        function startDrag(e) {
          let targetElement = event.currentTarget; // 这可能是子元素
          // 处理拖动逻辑...
          selectedElement = e.target;
          connectors[selectedElement.id] = connectors[selectedElement.id] || { x: 0, y: 0 };

        }

        function drag(evt) {
          if (selectedElement) {
            evt.preventDefault();
            const x = parseFloat(selectedElement.getAttribute('x')) || selectedElement.offsetLeft;
            const y = parseFloat(selectedElement.getAttribute('y')) || selectedElement.offsetTop;
            selectedElement.style.left = `${x + evt.movementX}px`;
            selectedElement.style.top = `${y + evt.movementY}px`;
            connectors[selectedElement.id].x = x + evt.movementX + selectedElement.offsetWidth / 2;
            connectors[selectedElement.id].y = y + evt.movementY + selectedElement.offsetHeight / 2;
            drawLine();
          }
        }

        function endDrag(evt) {
          selectedElement = null;
        }
      }

      function drawLine() {
        if (connectors['box1'] && connectors['box2']) {
          line.setAttribute('x1', connectors['box1'].x);
          line.setAttribute('y1', connectors['box1'].y);
          line.setAttribute('x2', connectors['box2'].x);
          line.setAttribute('y2', connectors['box2'].y);
        }
      }

      makeDraggable(document.querySelector('#box1'));
      makeDraggable(document.querySelector('#box2'));
    });
  </script>
</body>

</html>