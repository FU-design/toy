#### reactive()

- 创建响应式数据。
- 等价于 vue2.x 中的 <font color=red>Vue.observable()</font> 函数。
- 直接给 reactive 函数创建的响应式数据对象赋值，会让其丢失响应式
- （可使用 <font color=red>Object.assign()</font> 操作数组的方法：<font color=red>push</font>、<font color=red>shift</font>、<font color=red>pop</font> 等数组方法操作）。
- 直接解构 reactive 创建的响应式数据对象，会让其内部的属性丢失响应式
  （可利用 <font color=red>toRef()</font> <font color=red>toRefs()</font> 实现结构后的属性值仍然具备响应式，需通过<font color=red>属性值.value</font> 调用，模板中无需使用 <font color=red>.value</font>）。

#### ref()

- ref() 返回的是一个 <font color=red>value reference （包装对象）</font>。一个包装对象只有一个属性：<font color=red>.value</font>。该属性指向内部被包装的值。包装对象的值可以被直接修改。
- ref() 包装对象可以作为 reactive() 创建的对象的属性值
- 在模板中则无需使用 <font color=red>.value</font>
- 可通过 ref() 和 ref 属性标记的模板元素获取 **DOM** 或 **组件** 对象，vue2.x 中使用的是 <font color=red>this.$refs.标记值</font>

#### unref()

- 如果参数是一个 ref 则返回它的 value，否则返回参数本身。
- unref()：是 val = isRef(val) ? val.value : val 的语法糖。

#### isRef()

- 检查一下值是否为 ref\* 对象

#### toRefs() 和 toRef()

- 为响应式数据结构的解构提供便利
- 解构出来的属性不会丢失响应式
- toRefs() 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。
- toRef() 基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。 可通过 <font color=red>toRef(响应式结构对象,响应式结构对象中的某个属性)</font>

#### toValue()

- 将值、refs 或 getters 规范化为值。这与 unref() 类似，不同的是此函数也会规范化 getter 函数。如果参数是一个 getter，它将会被调用并且返回它的返回值。

  ```js
  toValue(1); //       --> 1
  toValue(ref(1)); //  --> 1
  toValue(() => 1); // --> 1
  ```

- 在组合式函数中规范化参数

  ```js
  import type { MaybeRefOrGetter } from "vue";

  function useFeature(id: MaybeRefOrGetter<number>) {
    watch(
      () => toValue(id),
      (id) => {
        // 处理 id 变更
      }
    );
  }

  // 这个组合式函数支持以下的任意形式：
  useFeature(1);
  useFeature(ref(1));
  useFeature(() => 1);
  ```
